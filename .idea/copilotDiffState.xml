<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/database/create-database-mysql.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database/create-database-mysql.sql" />
              <option name="originalContent" value="-- MySQL Database Schema for Raffles Manager&#10;-- Mode: MySQL&#10;&#10;DROP DATABASE IF EXISTS raffles;&#10;CREATE DATABASE raffles;&#10;USE raffles;&#10;&#10;CREATE TABLE proyects (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    isActive BOOLEAN DEFAULT true&#10;);&#10;&#10;CREATE TABLE rafflesSet (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    proyect_id INTEGER,&#10;    name VARCHAR(100) NOT NULL,&#10;    type VARCHAR(8) NOT NULL CHECK (type IN ('online', 'physical')),&#10;    init INTEGER NOT NULL,&#10;    final INTEGER NOT NULL,&#10;    unit_price INTEGER NOT NULL,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    CONSTRAINT valid_numbers CHECK (init &lt; final),&#10;    CONSTRAINT unique_set UNIQUE (proyect_id, name),&#10;    FOREIGN KEY (proyect_id) REFERENCES proyects(id)&#10;);&#10;&#10;CREATE TABLE buyers (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    email VARCHAR(100) UNIQUE NOT NULL,&#10;    phone VARCHAR(20),&#10;    register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE raffles (&#10;    set_id INTEGER NOT NULL,&#10;    number INTEGER NOT NULL,&#10;    sell_date TIMESTAMP,&#10;    buyer_id INTEGER,&#10;    payment_method VARCHAR(50) CHECK (payment_method in ('CASH', 'CARD', 'TRANSFER', 'OTHER')),&#10;    state VARCHAR(20) DEFAULT 'available' CHECK (state IN ('available', 'sold', 'reserved')),&#10;    FOREIGN KEY (buyer_id) REFERENCES buyers(id),&#10;    FOREIGN KEY (set_id) REFERENCES rafflesSet(id),&#10;    PRIMARY KEY (set_id, number),&#10;    UNIQUE KEY unique_number (number)&#10;);&#10;&#10;-- Trigger to generate raffle numbers when a new raffleSet is created&#10;DELIMITER //&#10;CREATE TRIGGER generate_raffles&#10;    AFTER INSERT ON rafflesSet&#10;    FOR EACH ROW&#10;BEGIN&#10;    DECLARE i INT DEFAULT NEW.init;&#10;    WHILE i &lt;= NEW.final DO&#10;        INSERT INTO raffles (set_id, number) VALUES (NEW.id, i);&#10;        SET i = i + 1;&#10;    END WHILE;&#10;END//&#10;DELIMITER ;&#10;" />
              <option name="updatedContent" value="-- MySQL Database Schema for Raffles Manager&#10;-- Mode: MySQL&#10;&#10;DROP DATABASE IF EXISTS raffles;&#10;CREATE DATABASE raffles;&#10;USE raffles;&#10;&#10;CREATE TABLE proyects (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    isActive BOOLEAN DEFAULT true&#10;);&#10;&#10;CREATE TABLE rafflesSet (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    proyect_id INTEGER,&#10;    name VARCHAR(100) NOT NULL,&#10;    type VARCHAR(8) NOT NULL CHECK (type IN ('online', 'physical')),&#10;    init INTEGER NOT NULL,&#10;    final INTEGER NOT NULL,&#10;    unit_price INTEGER NOT NULL,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    CONSTRAINT valid_numbers CHECK (init &lt; final),&#10;    CONSTRAINT unique_set UNIQUE (proyect_id, name),&#10;    FOREIGN KEY (proyect_id) REFERENCES proyects(id)&#10;);&#10;&#10;CREATE TABLE buyers (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    email VARCHAR(100) UNIQUE NOT NULL,&#10;    phone VARCHAR(20),&#10;    register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE raffles (&#10;    set_id INTEGER NOT NULL,&#10;    number INTEGER NOT NULL,&#10;    sell_date TIMESTAMP,&#10;    buyer_id INTEGER,&#10;    payment_method VARCHAR(50) CHECK (payment_method in ('CASH', 'CARD', 'TRANSFER', 'OTHER')),&#10;    state VARCHAR(20) DEFAULT 'available' CHECK (state IN ('available', 'sold', 'reserved')),&#10;    FOREIGN KEY (buyer_id) REFERENCES buyers(id),&#10;    FOREIGN KEY (set_id) REFERENCES rafflesSet(id),&#10;    PRIMARY KEY (set_id, number),&#10;    UNIQUE KEY unique_number (number)&#10;);&#10;&#10;DELIMITER //&#10;CREATE TRIGGER generate_raffles&#10;    AFTER INSERT ON rafflesSet&#10;    FOR EACH ROW&#10;BEGIN&#10;    DECLARE i INT DEFAULT NEW.init;&#10;    WHILE i &lt;= NEW.final DO&#10;        INSERT INTO raffles (set_id, number) VALUES (NEW.id, i);&#10;        SET i = i + 1;&#10;    END WHILE;&#10;END//&#10;DELIMITER ;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/database/create-database.mysql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database/create-database.mysql" />
              <option name="originalContent" value="-- @dialect mariadb&#10;&#10;DROP DATABASE raffles IF EXISTS;&#10;CREATE DATABASE raffles;&#10;USE raffles;&#10;&#10;CREATE TABLE proyects (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    isActive BOOLEAN DEFAULT true&#10;);&#10;&#10;CREATE TABLE rafflesSet (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    proyect_id INTEGER,&#10;    name VARCHAR(100) NOT NULL,&#10;    type VARCHAR(8) NOT NULL CHECK (type IN ('online', 'physical')),&#10;    init INTEGER NOT NULL,&#10;    final INTEGER NOT NULL,&#10;    unit_price INTEGER NOT NULL,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    CONSTRAINT valid_numbers CHECK (init &lt; final),&#10;    CONSTRAINT unique_set UNIQUE (proyect_id, name),&#10;    FOREIGN KEY (proyect_id) REFERENCES proyects(id)&#10;);&#10;&#10;CREATE TABLE buyers (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    email VARCHAR(100) UNIQUE NOT NULL,&#10;    phone VARCHAR(20),&#10;    register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE raffles (&#10;    set_id INTEGER NOT NULL,&#10;    number INTEGER NOT NULL,&#10;    sell_date TIMESTAMP,&#10;    buyer_id INTEGER,&#10;    payment_method VARCHAR(50) CHECK (payment_method in ('CASH', 'CARD', 'TRANSFER', 'OTHER')),&#10;    state VARCHAR(20) DEFAULT 'available' CHECK (state IN ('available', 'sold', 'reserved')),&#10;    FOREIGN KEY (buyer_id) REFERENCES buyers(id),&#10;    FOREIGN KEY (set_id) REFERENCES rafflesSet(id),&#10;    PRIMARY KEY (set_id, number),&#10;    UNIQUE KEY unique_number (number)&#10;);" />
              <option name="updatedContent" value="DROP DATABASE IF EXISTS raffles;&#10;CREATE DATABASE raffles;&#10;USE raffles;&#10;&#10;CREATE TABLE proyects (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    isActive BOOLEAN DEFAULT true&#10;);&#10;&#10;CREATE TABLE rafflesSet (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    proyect_id INTEGER,&#10;    name VARCHAR(100) NOT NULL,&#10;    type VARCHAR(8) NOT NULL CHECK (type IN ('online', 'physical')),&#10;    init INTEGER NOT NULL,&#10;    final INTEGER NOT NULL,&#10;    unit_price INTEGER NOT NULL,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    CONSTRAINT valid_numbers CHECK (init &lt; final),&#10;    CONSTRAINT unique_set UNIQUE (proyect_id, name),&#10;    FOREIGN KEY (proyect_id) REFERENCES proyects(id)&#10;);&#10;&#10;CREATE TABLE buyers (&#10;    id INT AUTO_INCREMENT PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    email VARCHAR(100) UNIQUE NOT NULL,&#10;    phone VARCHAR(20),&#10;    register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE raffles (&#10;    set_id INTEGER NOT NULL,&#10;    number INTEGER NOT NULL,&#10;    sell_date TIMESTAMP,&#10;    buyer_id INTEGER,&#10;    payment_method VARCHAR(50) CHECK (payment_method in ('CASH', 'CARD', 'TRANSFER', 'OTHER')),&#10;    state VARCHAR(20) DEFAULT 'available' CHECK (state IN ('available', 'sold', 'reserved')),&#10;    FOREIGN KEY (buyer_id) REFERENCES buyers(id),&#10;    FOREIGN KEY (set_id) REFERENCES rafflesSet(id),&#10;    PRIMARY KEY (set_id, number),&#10;    UNIQUE KEY unique_number (number)&#10;);&#10;&#10;-- Trigger to generate raffle numbers when a new raffleSet is created&#10;DELIMITER //&#10;CREATE TRIGGER generate_raffles&#10;    AFTER INSERT ON rafflesSet&#10;    FOR EACH ROW&#10;BEGIN&#10;    DECLARE i INT DEFAULT NEW.init;&#10;    WHILE i &lt;= NEW.final DO&#10;        INSERT INTO raffles (set_id, number) VALUES (NEW.id, i);&#10;        SET i = i + 1;&#10;    END WHILE;&#10;END//&#10;DELIMITER ;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/database/test_database.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database/test_database.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;        print(&quot;❌ Some tests failed. Please check the database setup.&quot;)&#10;        sys.exit(1)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/database/update_to_entity_manager.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database/update_to_entity_manager.sql" />
              <option name="updatedContent" value="-- MySQL Commands to Update Database to Entity-Manager Architecture&#10;-- ================================================================&#10;-- Run these commands in MySQL to update from user-based to entity-manager system&#10;&#10;USE raffles_db;&#10;&#10;-- Disable foreign key checks for structure changes&#10;SET FOREIGN_KEY_CHECKS = 0;&#10;&#10;-- 1. Drop all existing tables (in correct order to avoid FK conflicts)&#10;DROP TABLE IF EXISTS raffles;&#10;DROP TABLE IF EXISTS raffle_sets;&#10;DROP TABLE IF EXISTS projects;&#10;DROP TABLE IF EXISTS buyers;&#10;DROP TABLE IF EXISTS users;&#10;&#10;-- 2. Create new Entity-Manager tables&#10;CREATE TABLE entities (&#10;    id INT NOT NULL AUTO_INCREMENT,&#10;    name VARCHAR(100) NOT NULL,&#10;    hashed_password VARCHAR(255) NOT NULL,&#10;    description VARCHAR(500),&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (id),&#10;    UNIQUE KEY uk_entity_name (name),&#10;    KEY idx_entity_name (name)&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;CREATE TABLE managers (&#10;    entity_id INT NOT NULL,&#10;    manager_number INT NOT NULL,&#10;    username VARCHAR(50) NOT NULL,&#10;    hashed_password VARCHAR(255) NOT NULL,&#10;    is_active TINYINT(1) DEFAULT 1,&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (entity_id, manager_number),&#10;    UNIQUE KEY uk_manager_username (username),&#10;    KEY idx_manager_username (username),&#10;    KEY idx_manager_entity (entity_id),&#10;    CONSTRAINT fk_manager_entity FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;CREATE TABLE buyers (&#10;    entity_id INT NOT NULL,&#10;    buyer_number INT NOT NULL,&#10;    name VARCHAR(100) NOT NULL,&#10;    phone VARCHAR(20) NOT NULL,&#10;    email VARCHAR(100),&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (entity_id, buyer_number),&#10;    UNIQUE KEY uk_buyer_name_phone_entity (entity_id, name, phone),&#10;    KEY idx_buyer_entity (entity_id),&#10;    KEY idx_buyer_name_phone (name, phone),&#10;    CONSTRAINT fk_buyer_entity FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;CREATE TABLE projects (&#10;    entity_id INT NOT NULL,&#10;    project_number INT NOT NULL,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (entity_id, project_number),&#10;    KEY idx_project_entity (entity_id),&#10;    KEY idx_project_name (name),&#10;    CONSTRAINT fk_project_entity FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;CREATE TABLE raffle_sets (&#10;    entity_id INT NOT NULL,&#10;    project_number INT NOT NULL,&#10;    set_number INT NOT NULL,&#10;    name VARCHAR(60) NOT NULL,&#10;    type ENUM('online', 'physical') NOT NULL,&#10;    init INT NOT NULL,&#10;    final INT NOT NULL,&#10;    unit_price INT NOT NULL,&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (entity_id, project_number, set_number),&#10;    KEY idx_raffleset_entity_project (entity_id, project_number),&#10;    KEY idx_raffleset_name (name),&#10;    CONSTRAINT fk_raffleset_project FOREIGN KEY (entity_id, project_number) REFERENCES projects(entity_id, project_number) ON DELETE CASCADE,&#10;    CONSTRAINT chk_raffleset_valid_numbers CHECK (init &lt;= final),&#10;    CONSTRAINT chk_raffleset_type CHECK (type IN ('online', 'physical'))&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;CREATE TABLE raffles (&#10;    entity_id INT NOT NULL,&#10;    project_number INT NOT NULL,&#10;    raffle_number INT NOT NULL,&#10;    set_number INT NOT NULL,&#10;    buyer_entity_id INT,&#10;    buyer_number INT,&#10;    sold_by_entity_id INT,&#10;    sold_by_manager_number INT,&#10;    payment_method ENUM('cash', 'card', 'transfer'),&#10;    state ENUM('available', 'sold', 'reserved') DEFAULT 'available',&#10;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    PRIMARY KEY (entity_id, project_number, raffle_number),&#10;    KEY idx_raffle_entity_project (entity_id, project_number),&#10;    KEY idx_raffle_state (state),&#10;    KEY idx_raffle_buyer (buyer_entity_id, buyer_number),&#10;    KEY idx_raffle_manager (sold_by_entity_id, sold_by_manager_number),&#10;    CONSTRAINT fk_raffle_set FOREIGN KEY (entity_id, project_number, set_number) REFERENCES raffle_sets(entity_id, project_number, set_number) ON DELETE CASCADE,&#10;    CONSTRAINT fk_raffle_buyer FOREIGN KEY (buyer_entity_id, buyer_number) REFERENCES buyers(entity_id, buyer_number) ON DELETE SET NULL,&#10;    CONSTRAINT fk_raffle_manager FOREIGN KEY (sold_by_entity_id, sold_by_manager_number) REFERENCES managers(entity_id, manager_number) ON DELETE SET NULL,&#10;    CONSTRAINT chk_raffle_payment_method CHECK (payment_method IN ('cash', 'card', 'transfer')),&#10;    CONSTRAINT chk_raffle_state CHECK (state IN ('available', 'sold', 'reserved'))&#10;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&#10;&#10;-- 3. Create auto-increment triggers&#10;DELIMITER $$&#10;&#10;CREATE TRIGGER tr_managers_auto_increment&#10;    BEFORE INSERT ON managers&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.manager_number IS NULL OR NEW.manager_number = 0 THEN&#10;        SET NEW.manager_number = (&#10;            SELECT COALESCE(MAX(manager_number), 0) + 1&#10;            FROM managers&#10;            WHERE entity_id = NEW.entity_id&#10;        );&#10;    END IF;&#10;END$$&#10;&#10;CREATE TRIGGER tr_buyers_auto_increment&#10;    BEFORE INSERT ON buyers&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.buyer_number IS NULL OR NEW.buyer_number = 0 THEN&#10;        SET NEW.buyer_number = (&#10;            SELECT COALESCE(MAX(buyer_number), 0) + 1&#10;            FROM buyers&#10;            WHERE entity_id = NEW.entity_id&#10;        );&#10;    END IF;&#10;END$$&#10;&#10;CREATE TRIGGER tr_projects_auto_increment&#10;    BEFORE INSERT ON projects&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.project_number IS NULL OR NEW.project_number = 0 THEN&#10;        SET NEW.project_number = (&#10;            SELECT COALESCE(MAX(project_number), 0) + 1&#10;            FROM projects&#10;            WHERE entity_id = NEW.entity_id&#10;        );&#10;    END IF;&#10;END$$&#10;&#10;CREATE TRIGGER tr_raffle_sets_auto_increment&#10;    BEFORE INSERT ON raffle_sets&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.set_number IS NULL OR NEW.set_number = 0 THEN&#10;        SET NEW.set_number = (&#10;            SELECT COALESCE(MAX(set_number), 0) + 1&#10;            FROM raffle_sets&#10;            WHERE entity_id = NEW.entity_id AND project_number = NEW.project_number&#10;        );&#10;    END IF;&#10;END$$&#10;&#10;CREATE TRIGGER tr_raffles_auto_increment&#10;    BEFORE INSERT ON raffles&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.raffle_number IS NULL OR NEW.raffle_number = 0 THEN&#10;        SET NEW.raffle_number = (&#10;            SELECT COALESCE(MAX(raffle_number), 0) + 1&#10;            FROM raffles&#10;            WHERE entity_id = NEW.entity_id AND project_number = NEW.project_number&#10;        );&#10;    END IF;&#10;END$$&#10;&#10;DELIMITER ;&#10;&#10;-- Re-enable foreign key checks&#10;SET FOREIGN_KEY_CHECKS = 1;&#10;&#10;-- Show success message&#10;SELECT 'Database successfully updated to Entity-Manager architecture!' as message;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/README_AISLAMIENTO_ES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/README_AISLAMIENTO_ES.md" />
              <option name="updatedContent" value="# Sistema de Aislamiento por Usuario - Documentación&#10;&#10;## Introducción&#10;&#10;Este sistema implementa un **aislamiento completo de datos por usuario**, garantizando que cada usuario solo pueda acceder, modificar y eliminar sus propios datos. Ningún usuario puede ver o interactuar con información de otros usuarios.&#10;&#10;## Arquitectura del Sistema&#10;&#10;### Estructura de Datos Jerárquica&#10;&#10;```&#10;USUARIO (users)&#10;    ↓&#10;PROYECTOS (projects) &#10;    ↓&#10;SETS DE RIFAS (raffle_sets)&#10;    ↓&#10;RIFAS INDIVIDUALES (raffles)&#10;&#10;COMPRADORES (buyers) ← Independiente pero vinculado al usuario&#10;```&#10;&#10;### Diferencias Importantes en el Manejo de Email&#10;&#10;- **USERS (Usuarios del sistema)**: NO tienen email - autenticación solo con `username` y `password`&#10;- **BUYERS (Compradores)**: SÍ tienen email - información de contacto del comprador real&#10;&#10;## Cómo Funciona el Aislamiento&#10;&#10;### 1. Nivel Base - Usuario&#10;- Cada usuario se registra con `username` y `password` únicamente&#10;- Recibe un ID único que será la base de toda la jerarquía&#10;- No se almacena email para simplificar la autenticación&#10;&#10;### 2. Nivel 1 - Proyectos&#10;- Cada proyecto DEBE tener un `user_id` asignado&#10;- Un usuario solo puede ver/modificar proyectos donde `user_id = su_id`&#10;- Imposible acceder a proyectos de otros usuarios&#10;&#10;### 3. Nivel 2 - Sets de Rifas&#10;- Pertenecen a un proyecto específico&#10;- **TRIGGER automático** asigna el `user_id` del proyecto padre&#10;- Garantiza que el set pertenezca al mismo usuario que el proyecto&#10;&#10;### 4. Nivel 3 - Rifas Individuales&#10;- Pertenecen a un set específico&#10;- **TRIGGER automático** asigna el `user_id` del set padre&#10;- Mantiene la cadena de propiedad intacta&#10;&#10;### 5. Nivel Independiente - Compradores&#10;- Cada comprador DEBE tener un `user_id` asignado directamente&#10;- Incluye `email` para información de contacto&#10;- Un usuario solo puede ver/usar compradores donde `user_id = su_id`&#10;&#10;## Ejemplo Práctico&#10;&#10;### Escenario&#10;- **Usuario A**: ID=1, username=&quot;admin_tienda&quot;&#10;- **Usuario B**: ID=2, username=&quot;vendedor_local&quot;&#10;&#10;### Flujo de Datos&#10;&#10;#### 1. Usuario A crea un proyecto&#10;```sql&#10;INSERT INTO projects (name, description, user_id) &#10;VALUES ('Rifa Navideña 2024', 'Rifa para recaudar fondos navideños', 1);&#10;-- Resultado: project_id = 101, user_id = 1&#10;```&#10;&#10;#### 2. Usuario A crea un set en su proyecto&#10;```sql&#10;INSERT INTO raffle_sets (name, project_id, init, final, unit_price) &#10;VALUES ('Set Principal', 101, 1, 100, 50);&#10;-- TRIGGER automáticamente asigna user_id = 1&#10;-- Resultado: set_id = 501, user_id = 1 (automático)&#10;```&#10;&#10;#### 3. Usuario A crea rifas en su set&#10;```sql&#10;INSERT INTO raffles (number, set_id) VALUES (1, 501);&#10;INSERT INTO raffles (number, set_id) VALUES (2, 501);&#10;-- TRIGGER automáticamente asigna user_id = 1 a cada rifa&#10;```&#10;&#10;#### 4. Usuario B intenta acceder a datos del Usuario A&#10;```sql&#10;-- Esta consulta NO devuelve nada para Usuario B:&#10;SELECT * FROM projects WHERE user_id = 2;  -- VACÍO&#10;&#10;-- Esta tampoco:&#10;SELECT * FROM raffle_sets WHERE user_id = 2;  -- VACÍO&#10;&#10;-- Usuario B NO PUEDE ver datos del Usuario A&#10;```&#10;&#10;## Implementación en el Código&#10;&#10;### Consultas Seguras&#10;```python&#10;# ✅ CORRECTO - Siempre filtrar por user_id&#10;def get_user_projects(db: Session, current_user_id: int):&#10;    return db.query(Project).filter(Project.user_id == current_user_id).all()&#10;&#10;# ❌ INCORRECTO - Sin filtro de usuario (INSEGURO)&#10;def get_all_projects(db: Session):&#10;    return db.query(Project).all()  # Devuelve datos de TODOS los usuarios&#10;```&#10;&#10;### Validación de Propiedad&#10;```python&#10;def delete_project(db: Session, project_id: int, current_user_id: int):&#10;    # Verificar que el proyecto pertenece al usuario actual&#10;    project = db.query(Project).filter(&#10;        Project.id == project_id,&#10;        Project.user_id == current_user_id  # CLAVE: validar propiedad&#10;    ).first()&#10;    &#10;    if not project:&#10;        raise HTTPException(404, &quot;Proyecto no encontrado o no tienes permisos&quot;)&#10;    &#10;    db.delete(project)&#10;    db.commit()&#10;```&#10;&#10;## Flujo de Seguridad&#10;&#10;### 1. Autenticación&#10;- Usuario se registra/autentica con `username` y `password`&#10;- Recibe JWT token que contiene su `user_id`&#10;- No se requiere email para el proceso de autenticación&#10;&#10;### 2. Autorización&#10;- Cada request valida el JWT token&#10;- Extrae el `user_id` del token&#10;- Todas las consultas filtran por ese `user_id`&#10;&#10;### 3. Aislamiento&#10;- Imposible acceder a datos de otros usuarios&#10;- Triggers automáticos mantienen la integridad&#10;- Índices optimizan consultas por usuario&#10;&#10;## Protecciones Implementadas&#10;&#10;### A Nivel de Base de Datos&#10;- ✅ Cada tabla contiene `user_id`&#10;- ✅ Triggers automáticos propagan la propiedad&#10;- ✅ Índices compuestos optimizan consultas por usuario&#10;- ✅ Restricciones de integridad referencial&#10;- ✅ Autenticación simplificada sin email&#10;&#10;### A Nivel de Aplicación&#10;- ✅ Todas las queries filtran por `user_id`&#10;- ✅ Validación de propiedad antes de modificar/eliminar&#10;- ✅ JWT contiene el `user_id` del usuario autenticado&#10;- ✅ Middleware de seguridad en todas las rutas&#10;- ✅ Registro y login solo con username y password&#10;&#10;## Ventajas del Sistema&#10;&#10;1. **Aislamiento Completo**: Imposible acceso cruzado entre usuarios&#10;2. **Automatización**: Triggers manejan la propagación de propiedad&#10;3. **Escalabilidad**: Funciona eficientemente para miles de usuarios&#10;4. **Simplicidad**: Autenticación solo con username, sin complejidad de email&#10;5. **Auditoría**: Registro completo de accesos y modificaciones&#10;6. **Performance**: Índices optimizados para consultas por usuario&#10;7. **Flexibilidad**: Compradores pueden tener email para contacto&#10;&#10;## Casos de Uso&#10;&#10;### Registro de Usuario&#10;```python&#10;# Solo requiere username y password&#10;user_data = {&#10;    &quot;username&quot;: &quot;mi_tienda_online&quot;,&#10;    &quot;password&quot;: &quot;mi_password_seguro&quot;&#10;}&#10;```&#10;&#10;### Creación de Comprador&#10;```python&#10;# Puede incluir email para contacto&#10;buyer_data = {&#10;    &quot;name&quot;: &quot;Juan Pérez&quot;,&#10;    &quot;email&quot;: &quot;juan.perez@email.com&quot;,  # Para contacto&#10;    &quot;phone&quot;: &quot;+54911234567&quot;&#10;}&#10;```&#10;&#10;## Conclusión&#10;&#10;Este sistema garantiza que cada usuario opere en un entorno completamente aislado, donde solo puede acceder a sus propios datos. La diferenciación entre usuarios (sin email) y compradores (con email) permite una autenticación simple mientras mantiene la información de contacto necesaria para el negocio." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/README_ISOLATION_EN.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/README_ISOLATION_EN.md" />
              <option name="updatedContent" value="# User Isolation System - Documentation&#10;&#10;## Introduction&#10;&#10;This system implements **complete data isolation per user**, ensuring that each user can only access, modify, and delete their own data. No user can view or interact with information from other users.&#10;&#10;## System Architecture&#10;&#10;### Hierarchical Data Structure&#10;&#10;```&#10;USER (users)&#10;    ↓&#10;PROJECTS (projects) &#10;    ↓&#10;RAFFLE SETS (raffle_sets)&#10;    ↓&#10;INDIVIDUAL RAFFLES (raffles)&#10;&#10;BUYERS (buyers) ← Independent but linked to user&#10;```&#10;&#10;### Important Differences in Email Handling&#10;&#10;- **USERS (System users)**: NO email - authentication only with `username` and `password`&#10;- **BUYERS (Customers)**: YES email - contact information for the actual buyer&#10;&#10;## How Isolation Works&#10;&#10;### 1. Base Level - User&#10;- Each user registers with `username` and `password` only&#10;- Receives a unique ID that becomes the foundation of the entire hierarchy&#10;- No email stored to simplify authentication&#10;&#10;### 2. Level 1 - Projects&#10;- Each project MUST have an assigned `user_id`&#10;- A user can only view/modify projects where `user_id = their_id`&#10;- Impossible to access other users' projects&#10;&#10;### 3. Level 2 - Raffle Sets&#10;- Belong to a specific project&#10;- **Automatic TRIGGER** assigns the `user_id` from the parent project&#10;- Guarantees the set belongs to the same user as the project&#10;&#10;### 4. Level 3 - Individual Raffles&#10;- Belong to a specific set&#10;- **Automatic TRIGGER** assigns the `user_id` from the parent set&#10;- Maintains the ownership chain intact&#10;&#10;### 5. Independent Level - Buyers&#10;- Each buyer MUST have a `user_id` assigned directly&#10;- Includes `email` for contact information&#10;- A user can only view/use buyers where `user_id = their_id`&#10;&#10;## Practical Example&#10;&#10;### Scenario&#10;- **User A**: ID=1, username=&quot;store_admin&quot;&#10;- **User B**: ID=2, username=&quot;local_seller&quot;&#10;&#10;### Data Flow&#10;&#10;#### 1. User A creates a project&#10;```sql&#10;INSERT INTO projects (name, description, user_id) &#10;VALUES ('Christmas Raffle 2024', 'Fundraising raffle for Christmas', 1);&#10;-- Result: project_id = 101, user_id = 1&#10;```&#10;&#10;#### 2. User A creates a set in their project&#10;```sql&#10;INSERT INTO raffle_sets (name, project_id, init, final, unit_price) &#10;VALUES ('Main Set', 101, 1, 100, 50);&#10;-- TRIGGER automatically assigns user_id = 1&#10;-- Result: set_id = 501, user_id = 1 (automatic)&#10;```&#10;&#10;#### 3. User A creates raffles in their set&#10;```sql&#10;INSERT INTO raffles (number, set_id) VALUES (1, 501);&#10;INSERT INTO raffles (number, set_id) VALUES (2, 501);&#10;-- TRIGGER automatically assigns user_id = 1 to each raffle&#10;```&#10;&#10;#### 4. User B tries to access User A's data&#10;```sql&#10;-- This query returns NOTHING for User B:&#10;SELECT * FROM projects WHERE user_id = 2;  -- EMPTY&#10;&#10;-- Neither does this:&#10;SELECT * FROM raffle_sets WHERE user_id = 2;  -- EMPTY&#10;&#10;-- User B CANNOT see User A's data&#10;```&#10;&#10;## Code Implementation&#10;&#10;### Safe Queries&#10;```python&#10;# ✅ CORRECT - Always filter by user_id&#10;def get_user_projects(db: Session, current_user_id: int):&#10;    return db.query(Project).filter(Project.user_id == current_user_id).all()&#10;&#10;# ❌ INCORRECT - No user filter (UNSAFE)&#10;def get_all_projects(db: Session):&#10;    return db.query(Project).all()  # Returns data from ALL users&#10;```&#10;&#10;### Ownership Validation&#10;```python&#10;def delete_project(db: Session, project_id: int, current_user_id: int):&#10;    # Verify the project belongs to the current user&#10;    project = db.query(Project).filter(&#10;        Project.id == project_id,&#10;        Project.user_id == current_user_id  # KEY: validate ownership&#10;    ).first()&#10;    &#10;    if not project:&#10;        raise HTTPException(404, &quot;Project not found or you don't have permissions&quot;)&#10;    &#10;    db.delete(project)&#10;    db.commit()&#10;```&#10;&#10;## Security Flow&#10;&#10;### 1. Authentication&#10;- User registers/authenticates with `username` and `password`&#10;- Receives JWT token containing their `user_id`&#10;- No email required for authentication process&#10;&#10;### 2. Authorization&#10;- Each request validates the JWT token&#10;- Extracts the `user_id` from the token&#10;- All queries filter by that `user_id`&#10;&#10;### 3. Isolation&#10;- Impossible to access other users' data&#10;- Automatic triggers maintain integrity&#10;- Indexes optimize queries per user&#10;&#10;## Implemented Protections&#10;&#10;### Database Level&#10;- ✅ Each table contains `user_id`&#10;- ✅ Automatic triggers propagate ownership&#10;- ✅ Composite indexes optimize user queries&#10;- ✅ Referential integrity constraints&#10;- ✅ Simplified authentication without email&#10;&#10;### Application Level&#10;- ✅ All queries filter by `user_id`&#10;- ✅ Ownership validation before modify/delete&#10;- ✅ JWT contains authenticated user's `user_id`&#10;- ✅ Security middleware on all routes&#10;- ✅ Registration and login only with username and password&#10;&#10;## System Advantages&#10;&#10;1. **Complete Isolation**: Impossible cross-access between users&#10;2. **Automation**: Triggers handle ownership propagation&#10;3. **Scalability**: Works efficiently for thousands of users&#10;4. **Simplicity**: Authentication only with username, no email complexity&#10;5. **Auditing**: Complete record of access and modifications&#10;6. **Performance**: Optimized indexes for user queries&#10;7. **Flexibility**: Buyers can have email for contact&#10;&#10;## Use Cases&#10;&#10;### User Registration&#10;```python&#10;# Only requires username and password&#10;user_data = {&#10;    &quot;username&quot;: &quot;my_online_store&quot;,&#10;    &quot;password&quot;: &quot;my_secure_password&quot;&#10;}&#10;```&#10;&#10;### Buyer Creation&#10;```python&#10;# Can include email for contact&#10;buyer_data = {&#10;    &quot;name&quot;: &quot;John Doe&quot;,&#10;    &quot;email&quot;: &quot;john.doe@email.com&quot;,  # For contact&#10;    &quot;phone&quot;: &quot;+1234567890&quot;&#10;}&#10;```&#10;&#10;## Database Triggers&#10;&#10;### Auto-assign user_id in raffle_sets&#10;```sql&#10;CREATE TRIGGER tr_raffle_sets_user_id&#10;    BEFORE INSERT ON raffle_sets&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.user_id IS NULL THEN&#10;        SELECT user_id INTO NEW.user_id&#10;        FROM projects&#10;        WHERE id = NEW.project_id;&#10;    END IF;&#10;END&#10;```&#10;&#10;### Auto-assign user_id in raffles&#10;```sql&#10;CREATE TRIGGER tr_raffles_user_id&#10;    BEFORE INSERT ON raffles&#10;    FOR EACH ROW&#10;BEGIN&#10;    IF NEW.user_id IS NULL THEN&#10;        SELECT user_id INTO NEW.user_id&#10;        FROM raffle_sets&#10;        WHERE id = NEW.set_id;&#10;    END IF;&#10;END&#10;```&#10;&#10;## Security Policies&#10;&#10;### Always Use User Filtering&#10;```python&#10;# ✅ Secure pattern for all queries&#10;def get_user_data(db: Session, user_id: int):&#10;    projects = db.query(Project).filter(Project.user_id == user_id).all()&#10;    buyers = db.query(Buyer).filter(Buyer.user_id == user_id).all()&#10;    return {&quot;projects&quot;: projects, &quot;buyers&quot;: buyers}&#10;```&#10;&#10;### Validate Ownership Before Operations&#10;```python&#10;def update_raffle_set(db: Session, set_id: int, user_id: int, update_data: dict):&#10;    # First, verify ownership&#10;    raffle_set = db.query(RaffleSet).filter(&#10;        RaffleSet.id == set_id,&#10;        RaffleSet.user_id == user_id&#10;    ).first()&#10;    &#10;    if not raffle_set:&#10;        raise HTTPException(403, &quot;Access denied&quot;)&#10;    &#10;    # Then update&#10;    for key, value in update_data.items():&#10;        setattr(raffle_set, key, value)&#10;    &#10;    db.commit()&#10;```&#10;&#10;## Conclusion&#10;&#10;This system guarantees that each user operates in a completely isolated environment, where they can only access their own data. The differentiation between users (no email) and buyers (with email) allows for simple authentication while maintaining the contact information necessary for business operations.&#10;&#10;The automatic triggers and comprehensive indexing ensure both security and performance, making this system suitable for production environments with multiple concurrent users." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/english/database-erd-diagram.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/english/database-erd-diagram.md" />
              <option name="updatedContent" value="# Database Entity Relationship Diagram&#10;&#10;This diagram shows the complete database structure for the Raffles Manager system with composite primary keys and user isolation.&#10;&#10;```mermaid&#10;erDiagram&#10;    USERS ||--o{ PROJECTS : owns&#10;    USERS ||--o{ BUYERS : manages&#10;    USERS ||--o{ RAFFLE_SETS : creates&#10;    USERS ||--o{ RAFFLES : controls&#10;    PROJECTS ||--o{ RAFFLE_SETS : contains&#10;    RAFFLE_SETS ||--o{ RAFFLES : includes&#10;    BUYERS ||--o{ RAFFLES : purchases&#10;&#10;    USERS {&#10;        int id PK&#10;        string username UK &quot;UNIQUE, max 50 chars&quot;&#10;        string hashed_password &quot;max 255 chars&quot;&#10;        boolean is_active &quot;DEFAULT TRUE&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO ON UPDATE&quot;&#10;    }&#10;&#10;    PROJECTS {&#10;        int user_id PK,FK&#10;        int project_number PK &quot;Auto-increment per user&quot;&#10;        string name &quot;max 100 chars&quot;&#10;        text description &quot;Optional&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO ON UPDATE&quot;&#10;    }&#10;&#10;    BUYERS {&#10;        int user_id PK,FK&#10;        int buyer_number PK &quot;Auto-increment per user&quot;&#10;        string name &quot;max 100 chars&quot;&#10;        string phone &quot;max 20 chars, regex validated&quot;&#10;        string email &quot;Optional, validated email&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO ON UPDATE&quot;&#10;    }&#10;&#10;    RAFFLE_SETS {&#10;        int user_id PK,FK&#10;        int project_number PK,FK&#10;        int set_number PK &quot;Auto-increment per project&quot;&#10;        string name &quot;max 60 chars&quot;&#10;        string type &quot;online|physical&quot;&#10;        int init &quot;Starting raffle number&quot;&#10;        int final &quot;Ending raffle number&quot;&#10;        int unit_price &quot;Price in cents&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO ON UPDATE&quot;&#10;    }&#10;&#10;    RAFFLES {&#10;        int user_id PK,FK&#10;        int project_number PK,FK&#10;        int raffle_number PK &quot;Auto-increment per project&quot;&#10;        int set_number FK &quot;References raffle_sets&quot;&#10;        int buyer_user_id FK &quot;Optional, for purchases&quot;&#10;        int buyer_number FK &quot;Optional, for purchases&quot;&#10;        string payment_method &quot;cash|card|transfer&quot;&#10;        string state &quot;available|sold|reserved&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO ON UPDATE&quot;&#10;    }&#10;```&#10;&#10;## Database Architecture Overview&#10;&#10;### Composite Primary Key Strategy&#10;&#10;The database uses a hierarchical composite primary key structure for perfect user isolation:&#10;&#10;- **Users**: Simple auto-increment ID (foundation)&#10;- **Projects**: `(user_id, project_number)` - Each user has projects numbered 1, 2, 3...&#10;- **Buyers**: `(user_id, buyer_number)` - Each user has buyers numbered 1, 2, 3...&#10;- **Raffle Sets**: `(user_id, project_number, set_number)` - Each project has sets numbered 1, 2, 3...&#10;- **Raffles**: `(user_id, project_number, raffle_number)` - Each project has raffles numbered 1, 2, 3...&#10;&#10;### Key Features&#10;&#10;1. **User Isolation**: Every entity is scoped to a specific user&#10;2. **Predictable Numbering**: Each user sees their entities numbered from 1&#10;3. **Hierarchical Structure**: Clear parent-child relationships&#10;4. **Referential Integrity**: Proper foreign key constraints maintain data consistency&#10;&#10;### Constraints and Validations&#10;&#10;- **Unique Constraints**: `(user_id, name, phone)` for buyers to prevent duplicates&#10;- **Check Constraints**: &#10;  - Raffle set types: `online` or `physical`&#10;  - Payment methods: `cash`, `card`, or `transfer`&#10;  - Raffle states: `available`, `sold`, or `reserved`&#10;  - Number ranges: `init &lt;= final` for raffle sets&#10;&#10;### Relationship Types&#10;&#10;- **One-to-Many**: Users own multiple projects, buyers, raffle sets, and raffles&#10;- **Hierarchical**: Projects contain raffle sets, which contain individual raffles&#10;- **Optional**: Buyers can purchase raffles (nullable foreign key)&#10;- **Cascading Deletes**: Removing a user deletes all their data; removing a project deletes its sets and raffles" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/english/latest-fixes-and-improvements.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/english/latest-fixes-and-improvements.md" />
              <option name="updatedContent" value="# Latest Fixes and Improvements&#10;&#10;## Overview&#10;&#10;This document outlines the latest critical fixes applied to resolve SQLAlchemy relationship conflicts and registration failures that were occurring in production.&#10;&#10;## Issues Resolved&#10;&#10;### 1. SQLAlchemy Relationship Conflicts&#10;&#10;**Problem**: The application was experiencing SQLAlchemy warnings and initialization failures due to overlapping foreign key relationships between models. This was causing the User model's `hashed_password` field to not be recognized properly, resulting in registration failures with the error:&#10;&#10;```&#10;'hashed_password' is an invalid keyword argument for User&#10;```&#10;&#10;**Root Cause**: Multiple relationships were copying the same foreign key columns without proper overlap declarations, causing SQLAlchemy to be unable to determine the correct relationship mappings.&#10;&#10;**Solution**: Added proper `overlaps` parameters to all model relationships:&#10;&#10;- **User Model**: Added overlaps for `raffle_sets` and `raffles` relationships&#10;- **Project Model**: Added overlaps for `raffle_sets` relationship  &#10;- **RaffleSet Model**: Fixed overlaps between `user`, `project`, and `raffles` relationships&#10;- **Raffle Model**: Fixed overlaps between `user` and `raffle_set` relationships&#10;&#10;### 2. Database Initialization Issues&#10;&#10;**Problem**: The application wasn't properly initializing the database and tables on startup, leading to runtime errors when the database didn't exist.&#10;&#10;**Solution**: &#10;- Updated `main.py` to use modern FastAPI lifespan events&#10;- Added automatic database and table creation on application startup&#10;- Implemented proper error handling for database initialization failures&#10;&#10;### 3. Bcrypt Compatibility Issues&#10;&#10;**Problem**: Newer versions of bcrypt (4.3.0) were causing compatibility issues with the passlib library.&#10;&#10;**Solution**: Downgraded bcrypt to version 4.0.1 which maintains compatibility with passlib.&#10;&#10;## Technical Details&#10;&#10;### SQLAlchemy Relationship Fixes&#10;&#10;The core issue was that SQLAlchemy couldn't properly map relationships when multiple models had foreign keys pointing to the same columns. For example:&#10;&#10;- `RaffleSet.user_id` → `users.id`&#10;- `Project.user_id` → `users.id` &#10;- `RaffleSet.user_id` → `projects.user_id` (composite FK)&#10;&#10;This created ambiguity that SQLAlchemy couldn't resolve automatically. The solution was to explicitly declare which relationships overlap:&#10;&#10;```python&#10;# In User model&#10;raffle_sets = relationship(&quot;RaffleSet&quot;, back_populates=&quot;user&quot;, overlaps=&quot;projects&quot;)&#10;raffles = relationship(&quot;Raffle&quot;, back_populates=&quot;user&quot;, overlaps=&quot;projects,raffle_sets&quot;)&#10;&#10;# In RaffleSet model  &#10;user = relationship(&quot;User&quot;, back_populates=&quot;raffle_sets&quot;, overlaps=&quot;project&quot;)&#10;raffles = relationship(&quot;Raffle&quot;, back_populates=&quot;raffle_set&quot;, overlaps=&quot;user&quot;)&#10;```&#10;&#10;### Database Initialization Improvements&#10;&#10;Implemented modern FastAPI lifespan management:&#10;&#10;```python&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI):&#10;    &quot;&quot;&quot;Initialize database on startup&quot;&quot;&quot;&#10;    try:&#10;        from database import initialize_database&#10;        initialize_database()&#10;    except Exception as e:&#10;        print(f&quot;Warning: Database initialization failed: {e}&quot;)&#10;    &#10;    yield  # App runs here&#10;    &#10;    print(&quot;Application shutting down&quot;)&#10;```&#10;&#10;## Impact&#10;&#10;### Before Fixes&#10;- Registration endpoint returning 500 errors&#10;- SQLAlchemy warnings flooding logs&#10;- Inconsistent database initialization&#10;- Production deployment failures&#10;&#10;### After Fixes  &#10;- Clean user registration working correctly&#10;- No SQLAlchemy warnings&#10;- Reliable database initialization on startup&#10;- Stable production deployments&#10;&#10;## Testing&#10;&#10;To verify the fixes work correctly:&#10;&#10;1. **Registration Test**:&#10;```bash&#10;curl -X 'POST' \&#10;  'https://raffles-manager-api-production.up.railway.app/auth/register' \&#10;  -H 'Content-Type: application/json' \&#10;  -d '{&quot;username&quot;: &quot;testuser&quot;, &quot;password&quot;: &quot;testpass&quot;}'&#10;```&#10;&#10;2. **Database Initialization Test**:&#10;   - Delete the database&#10;   - Restart the application&#10;   - Verify tables are created automatically&#10;&#10;3. **Model Relationship Test**:&#10;   - Create users, projects, raffle sets, and raffles&#10;   - Verify all relationships work correctly&#10;   - Check that no SQLAlchemy warnings appear in logs&#10;&#10;## Deployment Notes&#10;&#10;These fixes are critical for production stability and should be deployed immediately. The changes are backward compatible and don't require database migrations since they only affect SQLAlchemy model definitions and application startup behavior.&#10;&#10;## Future Considerations&#10;&#10;- Monitor production logs for any remaining SQLAlchemy warnings&#10;- Consider implementing database health checks in the `/health` endpoint&#10;- Add automated tests for model relationship integrity&#10;- Implement database connection pooling optimizations if needed&#10;&#10;---&#10;&#10;*These fixes ensure the application has a solid foundation for reliable user registration and database operations.*" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/spanish/diagrama-erd-base-datos.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/spanish/diagrama-erd-base-datos.md" />
              <option name="updatedContent" value="# Diagrama de Entidad-Relación de Base de Datos&#10;&#10;Este diagrama muestra la estructura completa de la base de datos para el sistema Raffles Manager con claves primarias compuestas y aislamiento de usuarios.&#10;&#10;```mermaid&#10;erDiagram&#10;    USUARIOS ||--o{ PROYECTOS : posee&#10;    USUARIOS ||--o{ COMPRADORES : gestiona&#10;    USUARIOS ||--o{ SETS_RIFAS : crea&#10;    USUARIOS ||--o{ RIFAS : controla&#10;    PROYECTOS ||--o{ SETS_RIFAS : contiene&#10;    SETS_RIFAS ||--o{ RIFAS : incluye&#10;    COMPRADORES ||--o{ RIFAS : compra&#10;&#10;    USUARIOS {&#10;        int id PK&#10;        string username UK &quot;UNICO, max 50 caracteres&quot;&#10;        string hashed_password &quot;max 255 caracteres&quot;&#10;        boolean is_active &quot;DEFAULT TRUE&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO AL ACTUALIZAR&quot;&#10;    }&#10;&#10;    PROYECTOS {&#10;        int user_id PK,FK&#10;        int project_number PK &quot;Auto-incremento por usuario&quot;&#10;        string name &quot;max 100 caracteres&quot;&#10;        text description &quot;Opcional&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO AL ACTUALIZAR&quot;&#10;    }&#10;&#10;    COMPRADORES {&#10;        int user_id PK,FK&#10;        int buyer_number PK &quot;Auto-incremento por usuario&quot;&#10;        string name &quot;max 100 caracteres&quot;&#10;        string phone &quot;max 20 caracteres, validado con regex&quot;&#10;        string email &quot;Opcional, email validado&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO AL ACTUALIZAR&quot;&#10;    }&#10;&#10;    SETS_RIFAS {&#10;        int user_id PK,FK&#10;        int project_number PK,FK&#10;        int set_number PK &quot;Auto-incremento por proyecto&quot;&#10;        string name &quot;max 60 caracteres&quot;&#10;        string type &quot;online|physical&quot;&#10;        int init &quot;Número inicial de rifa&quot;&#10;        int final &quot;Número final de rifa&quot;&#10;        int unit_price &quot;Precio en centavos&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO AL ACTUALIZAR&quot;&#10;    }&#10;&#10;    RIFAS {&#10;        int user_id PK,FK&#10;        int project_number PK,FK&#10;        int raffle_number PK &quot;Auto-incremento por proyecto&quot;&#10;        int set_number FK &quot;Referencia a sets_rifas&quot;&#10;        int buyer_user_id FK &quot;Opcional, para compras&quot;&#10;        int buyer_number FK &quot;Opcional, para compras&quot;&#10;        string payment_method &quot;cash|card|transfer&quot;&#10;        string state &quot;available|sold|reserved&quot;&#10;        datetime created_at &quot;AUTO&quot;&#10;        datetime updated_at &quot;AUTO AL ACTUALIZAR&quot;&#10;    }&#10;```&#10;&#10;## Resumen de la Arquitectura de Base de Datos&#10;&#10;### Estrategia de Claves Primarias Compuestas&#10;&#10;La base de datos utiliza una estructura jerárquica de claves primarias compuestas para lograr un aislamiento perfecto de usuarios:&#10;&#10;- **Usuarios**: ID auto-incremento simple (base)&#10;- **Proyectos**: `(user_id, project_number)` - Cada usuario tiene proyectos numerados 1, 2, 3...&#10;- **Compradores**: `(user_id, buyer_number)` - Cada usuario tiene compradores numerados 1, 2, 3...&#10;- **Sets de Rifas**: `(user_id, project_number, set_number)` - Cada proyecto tiene sets numerados 1, 2, 3...&#10;- **Rifas**: `(user_id, project_number, raffle_number)` - Cada proyecto tiene rifas numeradas 1, 2, 3...&#10;&#10;### Características Principales&#10;&#10;1. **Aislamiento de Usuario**: Cada entidad está limitada a un usuario específico&#10;2. **Numeración Predecible**: Cada usuario ve sus entidades numeradas desde 1&#10;3. **Estructura Jerárquica**: Relaciones padre-hijo claras&#10;4. **Integridad Referencial**: Las restricciones de clave foránea mantienen la consistencia de datos&#10;&#10;### Restricciones y Validaciones&#10;&#10;- **Restricciones Únicas**: `(user_id, name, phone)` para compradores para prevenir duplicados&#10;- **Restricciones de Verificación**: &#10;  - Tipos de sets de rifas: `online` o `physical`&#10;  - Métodos de pago: `cash`, `card`, o `transfer`&#10;  - Estados de rifas: `available`, `sold`, o `reserved`&#10;  - Rangos de números: `init &lt;= final` para sets de rifas&#10;&#10;### Tipos de Relaciones&#10;&#10;- **Uno-a-Muchos**: Los usuarios poseen múltiples proyectos, compradores, sets de rifas y rifas&#10;- **Jerárquica**: Los proyectos contienen sets de rifas, que contienen rifas individuales&#10;- **Opcional**: Los compradores pueden comprar rifas (clave foránea anulable)&#10;- **Eliminación en Cascada**: Eliminar un usuario borra todos sus datos; eliminar un proyecto borra sus sets y rifas" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_minimal.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_minimal.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Minimal test to verify the application works&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;sys.path.insert(0, '/home/gonzadev/Proyectos/python/raffles-manager')&#10;&#10;def test_minimal():&#10;    &quot;&quot;&quot;Minimal test to check if basic functionality works&quot;&quot;&quot;&#10;    try:&#10;        print(&quot; Starting minimal test...&quot;)&#10;        &#10;        # Test 1: Basic imports&#10;        print(&quot;1. Testing basic imports...&quot;)&#10;        import fastapi&#10;        import sqlalchemy&#10;        print(&quot;✅ Basic dependencies imported&quot;)&#10;        &#10;        # Test 2: Environment variables&#10;        print(&quot;2. Testing environment...&quot;)&#10;        if os.path.exists('.env'):&#10;            print(&quot;✅ .env file exists&quot;)&#10;        else:&#10;            print(&quot;❌ .env file missing&quot;)&#10;            &#10;        # Test 3: Try config import&#10;        print(&quot;3. Testing config import...&quot;)&#10;        try:&#10;            from core.config_loader import settings&#10;            print(f&quot;✅ Config loaded - DB: {settings.MARIADB_DATABASE}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ Config failed: {e}&quot;)&#10;            return False&#10;            &#10;        # Test 4: Try database connection&#10;        print(&quot;4. Testing database connection...&quot;)&#10;        try:&#10;            from database.connection import engine&#10;            print(&quot;✅ Database engine created&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ Database failed: {e}&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ All basic tests passed!&quot;)&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Test failed: {e}&quot;)&#10;        return False&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    success = test_minimal()&#10;    if success:&#10;        print(&quot;\n Ready to run full tests!&quot;)&#10;    else:&#10;        print(&quot;\n Fix the issues above before running tests&quot;)&#10;        sys.exit(1)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_simple.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_simple.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Simplified test file that bypasses import hanging issues&#10;&quot;&quot;&quot;&#10;import sys&#10;import os&#10;&#10;# Add the project root to Python path&#10;sys.path.insert(0, '/home/gonzadev/Proyectos/python/raffles-manager')&#10;&#10;def test_basic_imports():&#10;    &quot;&quot;&quot;Test basic imports work&quot;&quot;&quot;&#10;    try:&#10;        print(&quot;Testing config import...&quot;)&#10;        from core.config_loader import settings&#10;        print(&quot;✅ Config loaded successfully&quot;)&#10;        &#10;        print(&quot;Testing database import...&quot;)&#10;        from database.connection import Base&#10;        print(&quot;✅ Database connection imported&quot;)&#10;        &#10;        print(&quot;Testing models import...&quot;)&#10;        from models.buyer import Buyer&#10;        print(&quot;✅ Models imported&quot;)&#10;        &#10;        print(&quot;Testing FastAPI app...&quot;)&#10;        from fastapi import FastAPI&#10;        app = FastAPI()&#10;        print(&quot;✅ FastAPI app created&quot;)&#10;        &#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;❌ Import failed: {e}&quot;)&#10;        return False&#10;&#10;def test_database_url():&#10;    &quot;&quot;&quot;Test database URL generation&quot;&quot;&quot;&#10;    try:&#10;        from core.config_loader import settings&#10;        db_url = str(settings.SQLALCHEMY_DATABASE_URI)&#10;        print(f&quot;Database URL: {db_url}&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;❌ Database URL test failed: {e}&quot;)&#10;        return False&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    print(&quot; Running simplified tests...&quot;)&#10;    &#10;    if test_basic_imports():&#10;        print(&quot;\n Testing database URL...&quot;)&#10;        test_database_url()&#10;        print(&quot;\n✅ Basic tests completed successfully!&quot;)&#10;    else:&#10;        print(&quot;\n❌ Basic tests failed!&quot;)&#10;        sys.exit(1)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/create-database-fixed.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/create-database-fixed.sql" />
              <option name="updatedContent" value="CREATE SCHEMA IF NOT EXISTS raffles_schema;&#10;&#10;SET search_path TO raffles_schema, public;&#10;&#10;CREATE TABLE proyects (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    description TEXT,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    isActive BOOL DEFAULT true&#10;);&#10;&#10;CREATE TABLE rafflesSet (&#10;    id SERIAL PRIMARY KEY,&#10;    proyect_id INTEGER REFERENCES proyects(id),&#10;    name VARCHAR(100) NOT NULL,&#10;    type VARCHAR(8) NOT NULL CHECK (type IN ('online', 'physical')),&#10;    init INTEGER NOT NULL,&#10;    final INTEGER NOT NULL,&#10;    unit_price INTEGER NOT NULL ,&#10;    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    CONSTRAINT valid_numbers CHECK (init &lt; final),&#10;    CONSTRAINT unique_set UNIQUE (proyect_id, name)&#10;);&#10;&#10;CREATE TABLE buyers (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(100) NOT NULL,&#10;    email VARCHAR(100) UNIQUE NOT NULL,&#10;    phone VARCHAR(20),&#10;    register_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE raffles ( -- Units&#10;    set_id INTEGER NOT NULL REFERENCES rafflesSet(id),&#10;    number INTEGER NOT NULL,&#10;    sell_date TIMESTAMP,&#10;    buyer_id INTEGER,&#10;    payment_method VARCHAR(50) CHECK (payment_method in ('CASH', 'CARD', 'TRANSFER', 'OTHER')),&#10;    state VARCHAR(20) DEFAULT 'available' CHECK (state IN ('available', 'sold', 'reserved')),&#10;    FOREIGN KEY (buyer_id) REFERENCES buyers(id),&#10;    PRIMARY KEY (set_id, number)&#10;);&#10;&#10;CREATE OR REPLACE FUNCTION generate_raffles()&#10;RETURNS TRIGGER AS $$&#10;DECLARE&#10;    next_number INTEGER;&#10;    count_numbers INTEGER;&#10;BEGIN&#10;&#10;    SELECT COALESCE(MAX(number), 0) + 1 INTO next_number FROM raffles;&#10;&#10;    -- Calculate how many numbers we need to generate&#10;    count_numbers := NEW.final - NEW.init + 1;&#10;&#10;    -- Update the rafflesSet with the actual init and final values&#10;    UPDATE rafflesSet&#10;    SET init = next_number,&#10;        final = next_number + count_numbers - 1&#10;    WHERE id = NEW.id;&#10;&#10;    -- Insert the raffle numbers&#10;    INSERT INTO raffles (set_id, number)&#10;    SELECT NEW.id, generate_series(next_number, next_number + count_numbers - 1);&#10;&#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;CREATE TRIGGER trig_generate_raffles&#10;AFTER INSERT ON rafflesSet&#10;FOR EACH ROW&#10;EXECUTE FUNCTION generate_raffles();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>